{"ast":null,"code":"var _jsxFileName = \"/Users/tobeyasinugo/dev/facechat_django/frontend/src/pages/chat.js\";\nimport React from 'react';\nimport { withRouter } from \"react-router-dom\";\nimport Publisher from '../components/Publisher';\nimport Subscriber from '../components/Subscriber';\nimport { OTSession, OTStreams, preloadScript } from 'opentok-react';\nimport ProfileLayout from '../components/Layout';\nimport opentokconfig from '../config';\nimport config from '../config';\nimport { authenticationService } from '../services/auth.service';\nimport { wsService } from '../services/ws.service';\nimport './chat.css';\nimport 'semantic-ui-css/semantic.min.css';\n\nconst OT = require('@opentok/client');\n\nconst qs = require('qs');\n\nclass Chat extends React.Component {\n  // Initial timeout duration as a class variable\n  constructor(props) {\n    super(props);\n    this.timeout = 250;\n\n    this.onWsEvent = data => {\n      console.log('ws event', data);\n\n      if (typeof data.callable != 'undefined') {\n        let hander = this.serverHandlers[data.callable];\n\n        if (typeof hander != 'undefined') {\n          hander(data);\n        } else {\n          console.log('[NO Handler]', data);\n        }\n      } else {\n        console.log('[UNHANLDED WS MSG]', data);\n      }\n    };\n\n    this.onWsError = err => {\n      console.log('Socket err', err);\n    };\n\n    this.onWsClose = () => {\n      console.log('Socket closed'); //     console.log(\n      //     `Socket is closed. Reconnect will be attempted in ${Math.min(\n      //         10000 / 1000,\n      //         (that.timeout + that.timeout) / 1000\n      //     )} second.`,\n      //     e.reason\n      // );\n      // that.timeout = that.timeout + that.timeout; //increment retry interval\n      // connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n    };\n\n    this.handle_user_details = data => {\n      if (typeof data.username != 'undefined' && typeof data.influencer != 'undefined') {\n        this.setState({\n          username: data.username,\n          influencer: data.influencer\n        });\n      }\n    };\n\n    this.handle_paytok_credentials = data => {\n      if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined') {\n        console.log('Joining session', data.session_id);\n        this.setState({\n          session: data.session_id,\n          token: data.token\n        });\n      }\n    };\n\n    this._isMounted = false;\n    this.serverHandlers = {\n      'user_details': this.handle_user_details,\n      'paytok_credentials': this.handle_paytok_credentials\n    };\n    this.state = {\n      auth: null,\n      session: null,\n      token: null,\n      connectionCount: 0,\n      session: null,\n      ws: null,\n      username: null,\n      isConnected: false,\n      influencer: null\n    };\n    this.sessionEventHandlers = {\n      connectionCreated: event => {\n        console.log(\"[NEW] connection created\", event);\n        var data = {\n          connectionId: event.connection.connectionId,\n          creationTime: event.connection.creationTime,\n          data: event.connection.data,\n          event: event.type,\n          sessionId: this.state.session,\n          callable: 'connection_created'\n        };\n        console.log('sending it', data);\n        authenticationService.ws.send(data);\n      },\n      connectionDestroyed: event => {\n        console.log(\"connection destroyed\", event);\n      },\n      sessionConnected: event => {\n        console.log(\"Client connect to a session\");\n      },\n      sessionDisconnected: event => {\n        console.log(\"Client disConnect to a session\");\n      },\n      sessionReconnected: event => {\n        console.log(\"session reconnected\");\n      }\n    };\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n    let data = {\n      influencer: this.props.match.params.influencer,\n      callable: 'exit_influencer_page'\n    };\n\n    if (this.state.ws) {\n      this.state.ws.next(data);\n    }\n  }\n\n  componentDidMount() {\n    this._isMounted = true; // https://stackoverflow.com/questions/52061476/cancel-all-subscriptions-and-asyncs-in-the-componentwillunmount-method-how\n\n    if (!this._isMounted || this.state.isConnected) {\n      return;\n    }\n\n    console.log(\"Mounted!\", this.state.auth, authenticationService.auth, authenticationService.auth.ws);\n    authenticationService.auth.subscribe(auth => {\n      console.log('chat auth.subscribe', auth);\n      authenticationService.refresh();\n      const ws_params = {\n        't': `Bearer ${auth.access}`\n      };\n      const ws = wsService.createWebSocketConnection(config.PAYTOK_WS_URL, ws_params);\n      this.setState({\n        auth,\n        ws\n      }, () => {\n        ws.subscribe(data => this.onWsEvent(data), err => this.onWsClose(err), () => this.onWsClose());\n        let data = {\n          influencer: this.props.match.params.influencer,\n          callable: 'enter_influencer_page'\n        };\n        ws.next(data);\n        this.setState({\n          isConnected: true\n        });\n      });\n    }); // authenticationService.auth.ws.send(data)\n    // this.connect()\n\n    console.log('connected to session', this.state);\n  }\n\n  //  connect = () => {\n  //       let token = authenticationService.accessToken\n  //       let params = { token }\n  //       let query_params = Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n  //       console.log('params', params)\n  //       var   ws = new WebSocket(`${config.PAYTOK_WS_URL}}/paytok/?${query_params}`)\n  //       let that = this; // cache the this\n  //       var connectInterval;\n  //       // websocket onopen event listener\n  //       ws.onopen = () => {\n  //           console.log(\"connected websocket main component\");\n  //           this.setState({ ws: ws });\n  //           that.timeout = 250; // reset timer to 250 on open of websocket connection\n  //           clearTimeout(connectInterval); // clear Interval on on open of websocket connection\n  //       };\n  //       // websocket onclose event listener\n  //       ws.onclose = e => {\n  //           console.log(\n  //               `Socket is closed. Reconnect will be attempted in ${Math.min(\n  //                   10000 / 1000,\n  //                   (that.timeout + that.timeout) / 1000\n  //               )} second.`,\n  //               e.reason\n  //           );\n  //           that.timeout = that.timeout + that.timeout; //increment retry interval\n  //           connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n  //       };\n  //       // websocket onerror event listener\n  //       ws.onerror = err => {\n  //           console.error(\n  //               \"Socket encountered error: \",\n  //               err.message,\n  //               \"Closing socket\"\n  //           );\n  //           ws.close();\n  //       };\n  //       ws.addEventListener('message', function (event) {\n  //           console.log('Message from server ', event.data);\n  //           var data = JSON.parse(event.data)\n  //           if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined' ) {\n  //                   console.log('Joining session', data.session_id);\n  //                  that.setState({session: data.session_id, token: data.token, connectionCount: 2})\n  //           }\n  //           if (typeof data.username != 'undefined' ) {\n  //              that.setState({username: data.username})\n  //           }\n  //       });\n  //   };\n\n  /**\n   * utilited by the @function connect to check if the connection is close, if so attempts to reconnect\n   */\n  // check = () => {\n  //     const { ws } = this.state;\n  //     if (!ws || ws.readyState == WebSocket.CLOSED) this.connect(); //check if websocket instance is closed, if so call `connect` function.\n  // };\n  render() {\n    {\n      console.log('renderrrr', this.state);\n    }\n\n    if (this.state.session == null) {\n      if (this.state.username != null && this.state.influencer != null) {\n        {\n          console.log('infullnecerr', this.state.influencer);\n        }\n        return /*#__PURE__*/React.createElement(ProfileLayout, {\n          username: this.state.username,\n          influencerFirstName: this.state.influencer.user.first_name,\n          influencerLastName: this.state.influencer.user.last_name,\n          category: this.state.influencer.category,\n          description1: this.state.influencer.description1,\n          description2: this.state.influencer.description2,\n          per_slot: this.state.influencer.per_slot,\n          slot: this.state.influencer.slot,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 262,\n            columnNumber: 21\n          }\n        });\n      } else {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 274,\n            columnNumber: 21\n          }\n        }, \"Loading..\");\n      }\n    } else {\n      return /*#__PURE__*/React.createElement(OTSession, {\n        apiKey: opentokconfig.API_KEY,\n        sessionId: this.state.session,\n        token: this.state.token,\n        eventHandlers: this.sessionEventHandlers,\n        onError: this.onError,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 278,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(OTStreams, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 286,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(Subscriber, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 287,\n          columnNumber: 13\n        }\n      })), /*#__PURE__*/React.createElement(Publisher, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 289,\n          columnNumber: 9\n        }\n      }));\n    }\n  }\n\n}\n\nexport default withRouter(Chat);","map":{"version":3,"sources":["/Users/tobeyasinugo/dev/facechat_django/frontend/src/pages/chat.js"],"names":["React","withRouter","Publisher","Subscriber","OTSession","OTStreams","preloadScript","ProfileLayout","opentokconfig","config","authenticationService","wsService","OT","require","qs","Chat","Component","constructor","props","timeout","onWsEvent","data","console","log","callable","hander","serverHandlers","onWsError","err","onWsClose","handle_user_details","username","influencer","setState","handle_paytok_credentials","token","session_id","session","_isMounted","state","auth","connectionCount","ws","isConnected","sessionEventHandlers","connectionCreated","event","connectionId","connection","creationTime","type","sessionId","send","connectionDestroyed","sessionConnected","sessionDisconnected","sessionReconnected","componentWillUnmount","match","params","next","componentDidMount","subscribe","refresh","ws_params","access","createWebSocketConnection","PAYTOK_WS_URL","render","user","first_name","last_name","category","description1","description2","per_slot","slot","API_KEY","onError"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { withRouter } from \"react-router-dom\";\n\nimport Publisher from '../components/Publisher';\nimport Subscriber  from '../components/Subscriber';\nimport { OTSession, OTStreams, preloadScript } from 'opentok-react';\n\nimport ProfileLayout from '../components/Layout';\n\n\nimport opentokconfig from '../config';\nimport config from '../config';\nimport { authenticationService } from '../services/auth.service';\nimport  { wsService } from '../services/ws.service'\n\n\nimport './chat.css'\nimport 'semantic-ui-css/semantic.min.css';\n\nconst OT = require('@opentok/client');\nconst qs = require('qs');\n\nclass Chat extends React.Component {\n  timeout = 250; // Initial timeout duration as a class variable\n\n\n  constructor(props) {\n    super(props);\n\n    this._isMounted = false;\n\n    this.serverHandlers  = {\n      'user_details': this.handle_user_details,\n      'paytok_credentials': this.handle_paytok_credentials,\n    }\n\n    this.state = {\n      auth: null,\n      session: null,\n      token: null,\n      connectionCount: 0,\n      session: null,\n      ws: null,\n      username: null,\n      isConnected: false,\n      influencer: null,\n    }\n    \n\n this.sessionEventHandlers = {\n      connectionCreated: event =>  {\n          console.log(\"[NEW] connection created\", event);\n          var data = {\n            connectionId: event.connection.connectionId,\n            creationTime: event.connection.creationTime,\n            data: event.connection.data,\n            event: event.type,\n            sessionId: this.state.session,\n            callable: 'connection_created',\n\n          }\n          console.log('sending it', data)\n          authenticationService.ws.send(data);\n\n\n      },\n      connectionDestroyed: event =>  {\n          console.log(\"connection destroyed\", event);\n      },\n      sessionConnected: event => {\n          console.log(\"Client connect to a session\")\n      },\n      sessionDisconnected: event => {\n        console.log(\"Client disConnect to a session\")\n      },\n      sessionReconnected: event => {\n        console.log(\"session reconnected\")\n      },\n    };\n  }\n\n  componentWillUnmount() {\n\n    this._isMounted = false;\n    let data = {\n      influencer: this.props.match.params.influencer,\n      callable: 'exit_influencer_page'\n    }\n    if (this.state.ws) {\n        this.state.ws.next(data)\n    }\n }\n \n  componentDidMount() {\n    this._isMounted = true; // https://stackoverflow.com/questions/52061476/cancel-all-subscriptions-and-asyncs-in-the-componentwillunmount-method-how\n    if (!this._isMounted || this.state.isConnected) {\n        return\n    }\n    console.log(\"Mounted!\", this.state.auth, authenticationService.auth, authenticationService.auth.ws)\n\n\n    authenticationService.auth.subscribe(auth => {\n      console.log('chat auth.subscribe', auth)\n      authenticationService.refresh()\n      const ws_params = { 't': `Bearer ${auth.access}`}\n      const ws = wsService.createWebSocketConnection(config.PAYTOK_WS_URL, ws_params)\n      this.setState({ auth, ws }, () => {\n\n      ws.subscribe(\n          (data) => this.onWsEvent(data),\n          (err) => this.onWsClose(err),\n          () => this.onWsClose(),\n      );\n      let data = {\n        influencer: this.props.match.params.influencer,\n        callable: 'enter_influencer_page'\n      }\n      ws.next(data)\n      this.setState({ isConnected: true })\n\n      });\n    })\n\n    // authenticationService.auth.ws.send(data)\n\n    // this.connect()\n    console.log('connected to session', this.state)\n  }\n\n  onWsEvent = (data) => {\n    console.log('ws event', data)\n\n    if (typeof data.callable != 'undefined') {\n      let hander = this.serverHandlers[data.callable]\n      if (typeof hander != 'undefined') {\n          hander(data)\n      } else {\n        console.log('[NO Handler]', data)\n      }\n\n    } else {\n      console.log('[UNHANLDED WS MSG]', data)\n    }\n\n  }\n\n  onWsError = (err) => {\n    console.log('Socket err', err)\n  }\n\n  onWsClose = () => {\n    console.log('Socket closed')\n\n        //     console.log(\n        //     `Socket is closed. Reconnect will be attempted in ${Math.min(\n        //         10000 / 1000,\n        //         (that.timeout + that.timeout) / 1000\n        //     )} second.`,\n        //     e.reason\n        // );\n\n        // that.timeout = that.timeout + that.timeout; //increment retry interval\n        // connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n  }\n\n\n  handle_user_details = (data) => {\n    if (typeof data.username != 'undefined' && typeof data.influencer != 'undefined') {\n        this.setState({username: data.username, influencer: data.influencer})\n\n    }\n\n  }\n\n\n  handle_paytok_credentials = (data) => {\n\n    if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined' ) {\n      console.log('Joining session', data.session_id);\n      this.setState({session: data.session_id, token: data.token})\n\n    }\n    \n  }\n\n  //  connect = () => {\n  //       let token = authenticationService.accessToken\n  //       let params = { token }\n  //       let query_params = Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n\n  //       console.log('params', params)\n  //       var   ws = new WebSocket(`${config.PAYTOK_WS_URL}}/paytok/?${query_params}`)\n  //       let that = this; // cache the this\n  //       var connectInterval;\n  //       // websocket onopen event listener\n  //       ws.onopen = () => {\n  //           console.log(\"connected websocket main component\");\n\n  //           this.setState({ ws: ws });\n\n  //           that.timeout = 250; // reset timer to 250 on open of websocket connection\n  //           clearTimeout(connectInterval); // clear Interval on on open of websocket connection\n  //       };\n  //       // websocket onclose event listener\n  //       ws.onclose = e => {\n  //           console.log(\n  //               `Socket is closed. Reconnect will be attempted in ${Math.min(\n  //                   10000 / 1000,\n  //                   (that.timeout + that.timeout) / 1000\n  //               )} second.`,\n  //               e.reason\n  //           );\n\n  //           that.timeout = that.timeout + that.timeout; //increment retry interval\n  //           connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n  //       };\n\n  //       // websocket onerror event listener\n  //       ws.onerror = err => {\n  //           console.error(\n  //               \"Socket encountered error: \",\n  //               err.message,\n  //               \"Closing socket\"\n  //           );\n\n  //           ws.close();\n  //       };\n\n  //       ws.addEventListener('message', function (event) {\n  //           console.log('Message from server ', event.data);\n  //           var data = JSON.parse(event.data)\n  //           if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined' ) {\n  //                   console.log('Joining session', data.session_id);\n  //                  that.setState({session: data.session_id, token: data.token, connectionCount: 2})\n\n  //           }\n\n  //           if (typeof data.username != 'undefined' ) {\n  //              that.setState({username: data.username})\n\n  //           }\n\n  //       });\n  //   };\n    /**\n     * utilited by the @function connect to check if the connection is close, if so attempts to reconnect\n     */\n    // check = () => {\n    //     const { ws } = this.state;\n    //     if (!ws || ws.readyState == WebSocket.CLOSED) this.connect(); //check if websocket instance is closed, if so call `connect` function.\n    // };\n\n\n  render() {\n    {console.log('renderrrr', this.state)}\n\n    if (this.state.session == null ){\n\n       if (this.state.username != null && this.state.influencer != null) {\n        {console.log('infullnecerr', this.state.influencer)}\n\n             return <ProfileLayout \n                      username={this.state.username}\n                      influencerFirstName={this.state.influencer.user.first_name}\n                      influencerLastName={this.state.influencer.user.last_name}\n                      category={this.state.influencer.category}\n                      description1={this.state.influencer.description1}\n                      description2={this.state.influencer.description2}\n                      per_slot={this.state.influencer.per_slot}\n                      slot={this.state.influencer.slot}\n              />\n\n       } else  {\n             return <div>Loading..</div>\n       }\n    } else {\n      return (\n          <OTSession\n          apiKey={opentokconfig.API_KEY}\n          sessionId={this.state.session}\n          token={this.state.token}\n          eventHandlers={this.sessionEventHandlers}\n          onError={this.onError}\n    >\n\n          <OTStreams>\n            <Subscriber/>\n        </OTStreams>\n        <Publisher/>\n      </OTSession>\n      )\n    }\n  }\n\n\n}\nexport default  withRouter(Chat) \n\n"]},"metadata":{},"sourceType":"module"}