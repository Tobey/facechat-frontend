{"ast":null,"code":"var _jsxFileName = \"/Users/tobeyasinugo/dev/facechat_django/frontend/src/pages/chat.js\";\nimport React from 'react';\nimport Publisher from '../components/Publisher';\nimport Subscriber from '../components/Subscriber';\nimport { OTSession, OTStreams, preloadScript } from 'opentok-react';\nimport opentokconfig from '../config';\nimport { withRouter } from \"react-router-dom\";\nimport './chat.css';\nimport 'semantic-ui-css/semantic.min.css';\nimport config from '../config';\nimport { authenticationService } from '../services/auth.service';\nimport { wsService } from '../services/ws.service';\n\nconst OT = require('@opentok/client');\n\nconst qs = require('qs');\n\nclass Chat extends React.Component {\n  // Initial timeout duration as a class variable\n  constructor(props) {\n    super(props);\n    this.timeout = 250;\n\n    this.check = () => {\n      const {\n        ws\n      } = this.state;\n      if (!ws || ws.readyState == WebSocket.CLOSED) this.connect(); //check if websocket instance is closed, if so call `connect` function.\n    };\n\n    this.state = {\n      auth: null,\n      session: null,\n      token: null,\n      connectionCount: 0,\n      session: null,\n      ws: null,\n      username: null,\n      isConnected: false\n    };\n    this._isMounted = false;\n    this.sessionEventHandlers = {\n      connectionCreated: event => {\n        console.log(\"[NEW] connection created\", event);\n        var data = {\n          connectionId: event.connection.connectionId,\n          creationTime: event.connection.creationTime,\n          data: event.connection.data,\n          event: event.type,\n          sessionId: this.state.session,\n          parser: 'connection_created'\n        };\n        console.log('sending it', data);\n        authenticationService.ws.send(data);\n      },\n      connectionDestroyed: event => {\n        console.log(\"connection destroyed\", event);\n      },\n      sessionConnected: event => {\n        console.log(\"Client connect to a session\");\n      },\n      sessionDisconnected: event => {\n        console.log(\"Client disConnect to a session\");\n      },\n      sessionReconnected: event => {\n        console.log(\"session reconnected\");\n      }\n    };\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n    let data = {\n      influencerUsername: this.props.match.params.influencer,\n      parser: 'exit_influencer_page'\n    };\n\n    if (authenticationService.auth.ws) {\n      authenticationService.auth.ws.send(data);\n    }\n  }\n\n  componentDidMount() {\n    this._isMounted = true; // https://stackoverflow.com/questions/52061476/cancel-all-subscriptions-and-asyncs-in-the-componentwillunmount-method-how\n\n    if (!this._isMounted) {\n      return;\n    }\n\n    console.log(\"Mounted!\", this.state.auth, authenticationService.auth, authenticationService.auth.ws);\n    authenticationService.auth.subscribe(auth => {\n      console.log('chat auth.subscribe', auth);\n      const ws_params = {\n        't': `Bearer ${auth.access}`\n      };\n      const ws = wsService.createWebSocketConnection(config.PAYTOK_WS_URL, ws_params);\n      this.setState({\n        auth,\n        ws\n      }, () => {\n        ws.connectionStatus$.subscribe(isConnected => {\n          if (isConnected) {\n            console.log('dong stuuff with ws', ws);\n            ws.on('event', data => console.log('server msg::: ', data)); // will display received data in console if event is fired\n\n            ws.on('close', () => console.log('Socket closed')); // will \n\n            let data = {\n              influencerUsername: this.props.match.params.influencer,\n              parser: 'enter_influencer_page'\n            };\n            ws.send(data);\n          }\n\n          this.setState({\n            isConnected\n          });\n        });\n      });\n    });\n    let data = {\n      influencerUsername: this.props.match.params.influencer,\n      parser: 'enter_influencer_page'\n    }; // authenticationService.auth.ws.send(data)\n    // this.connect()\n\n    console.log('connected to session', this.state);\n  } //  connect = () => {\n  //       let token = authenticationService.accessToken\n  //       let params = { token }\n  //       let query_params = Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n  //       console.log('params', params)\n  //       var   ws = new WebSocket(`${config.PAYTOK_WS_URL}}/paytok/?${query_params}`)\n  //       let that = this; // cache the this\n  //       var connectInterval;\n  //       // websocket onopen event listener\n  //       ws.onopen = () => {\n  //           console.log(\"connected websocket main component\");\n  //           this.setState({ ws: ws });\n  //           that.timeout = 250; // reset timer to 250 on open of websocket connection\n  //           clearTimeout(connectInterval); // clear Interval on on open of websocket connection\n  //       };\n  //       // websocket onclose event listener\n  //       ws.onclose = e => {\n  //           console.log(\n  //               `Socket is closed. Reconnect will be attempted in ${Math.min(\n  //                   10000 / 1000,\n  //                   (that.timeout + that.timeout) / 1000\n  //               )} second.`,\n  //               e.reason\n  //           );\n  //           that.timeout = that.timeout + that.timeout; //increment retry interval\n  //           connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n  //       };\n  //       // websocket onerror event listener\n  //       ws.onerror = err => {\n  //           console.error(\n  //               \"Socket encountered error: \",\n  //               err.message,\n  //               \"Closing socket\"\n  //           );\n  //           ws.close();\n  //       };\n  //       ws.addEventListener('message', function (event) {\n  //           console.log('Message from server ', event.data);\n  //           var data = JSON.parse(event.data)\n  //           if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined' ) {\n  //                   console.log('Joining session', data.session_id);\n  //                  that.setState({session: data.session_id, token: data.token, connectionCount: 2})\n  //           }\n  //           if (typeof data.username != 'undefined' ) {\n  //              that.setState({username: data.username})\n  //           }\n  //       });\n  //   };\n\n  /**\n   * utilited by the @function connect to check if the connection is close, if so attempts to reconnect\n   */\n\n\n  render() {\n    {\n      console.log('renderrrr', this.state);\n    }\n\n    if (this.state.session == null) {\n      if (this.state.username != null) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 202,\n            columnNumber: 21\n          }\n        }, \"Hi \", this.state.username, \" \");\n      } else {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 205,\n            columnNumber: 21\n          }\n        }, \"Loading..\");\n      }\n    } else {\n      return /*#__PURE__*/React.createElement(OTSession, {\n        apiKey: opentokconfig.API_KEY,\n        sessionId: this.state.session,\n        token: this.state.token,\n        eventHandlers: this.sessionEventHandlers,\n        onError: this.onError,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 209,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(OTStreams, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 217,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(Subscriber, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 13\n        }\n      })), /*#__PURE__*/React.createElement(Publisher, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 220,\n          columnNumber: 9\n        }\n      }));\n    }\n  }\n\n}\n\nexport default withRouter(Chat);","map":{"version":3,"sources":["/Users/tobeyasinugo/dev/facechat_django/frontend/src/pages/chat.js"],"names":["React","Publisher","Subscriber","OTSession","OTStreams","preloadScript","opentokconfig","withRouter","config","authenticationService","wsService","OT","require","qs","Chat","Component","constructor","props","timeout","check","ws","state","readyState","WebSocket","CLOSED","connect","auth","session","token","connectionCount","username","isConnected","_isMounted","sessionEventHandlers","connectionCreated","event","console","log","data","connectionId","connection","creationTime","type","sessionId","parser","send","connectionDestroyed","sessionConnected","sessionDisconnected","sessionReconnected","componentWillUnmount","influencerUsername","match","params","influencer","componentDidMount","subscribe","ws_params","access","createWebSocketConnection","PAYTOK_WS_URL","setState","connectionStatus$","on","render","API_KEY","onError"],"mappings":"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","sourcesContent":["import React from 'react';\nimport Publisher from '../components/Publisher';\nimport Subscriber  from '../components/Subscriber';\nimport { OTSession, OTStreams, preloadScript } from 'opentok-react';\nimport opentokconfig from '../config';\nimport { withRouter } from \"react-router-dom\";\nimport './chat.css'\nimport 'semantic-ui-css/semantic.min.css';\n\nimport config from '../config';\nimport { authenticationService } from '../services/auth.service';\nimport  { wsService } from '../services/ws.service'\n\n\nconst OT = require('@opentok/client');\nconst qs = require('qs');\n\nclass Chat extends React.Component {\n  timeout = 250; // Initial timeout duration as a class variable\n\n  constructor(props) {\n    super(props);\n\n\n    this.state = {\n      auth: null,\n      session: null,\n      token: null,\n      connectionCount: 0,\n      session: null,\n      ws: null,\n      username: null,\n      isConnected: false,\n    }\n    this._isMounted = false;\n\n this.sessionEventHandlers = {\n      connectionCreated: event =>  {\n          console.log(\"[NEW] connection created\", event);\n          var data = {\n            connectionId: event.connection.connectionId,\n            creationTime: event.connection.creationTime,\n            data: event.connection.data,\n            event: event.type,\n            sessionId: this.state.session,\n            parser: 'connection_created',\n\n          }\n          console.log('sending it', data)\n          authenticationService.ws.send(data);\n\n\n      },\n      connectionDestroyed: event =>  {\n          console.log(\"connection destroyed\", event);\n      },\n      sessionConnected: event => {\n          console.log(\"Client connect to a session\")\n      },\n      sessionDisconnected: event => {\n        console.log(\"Client disConnect to a session\")\n      },\n      sessionReconnected: event => {\n        console.log(\"session reconnected\")\n      },\n    };\n  }\n\n  componentWillUnmount() {\n\n    this._isMounted = false;\n    let data = {\n      influencerUsername: this.props.match.params.influencer,\n      parser: 'exit_influencer_page'\n    }\n    if (authenticationService.auth.ws) {\n        authenticationService.auth.ws.send(data)\n    }\n }\n \n  componentDidMount() {\n    this._isMounted = true; // https://stackoverflow.com/questions/52061476/cancel-all-subscriptions-and-asyncs-in-the-componentwillunmount-method-how\n    if (!this._isMounted) {\n        return\n    }\n\n\n    console.log(\"Mounted!\", this.state.auth, authenticationService.auth, authenticationService.auth.ws)\n\n    authenticationService.auth.subscribe(auth => {\n      console.log('chat auth.subscribe', auth)\n      const ws_params = { 't': `Bearer ${auth.access}`}\n      const ws = wsService.createWebSocketConnection(config.PAYTOK_WS_URL, ws_params)\n      this.setState({ auth, ws }, () => {\n\n\n\n\n        ws.connectionStatus$.subscribe(isConnected => {\n          if (isConnected) {\n            console.log('dong stuuff with ws', ws)\n            ws.on('event', data => console.log('server msg::: ', data)); // will display received data in console if event is fired\n            ws.on('close', () => console.log('Socket closed')); // will \n            let data = {\n              influencerUsername: this.props.match.params.influencer,\n              parser: 'enter_influencer_page'\n            }\n            ws.send(data)\n          }\n          this.setState({ isConnected })\n        })\n\n\n      });\n    })\n\n    let data = {\n      influencerUsername: this.props.match.params.influencer,\n      parser: 'enter_influencer_page'\n    }\n    // authenticationService.auth.ws.send(data)\n\n    // this.connect()\n    console.log('connected to session', this.state)\n  }\n\n\n\n  //  connect = () => {\n  //       let token = authenticationService.accessToken\n  //       let params = { token }\n  //       let query_params = Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n\n  //       console.log('params', params)\n  //       var   ws = new WebSocket(`${config.PAYTOK_WS_URL}}/paytok/?${query_params}`)\n  //       let that = this; // cache the this\n  //       var connectInterval;\n  //       // websocket onopen event listener\n  //       ws.onopen = () => {\n  //           console.log(\"connected websocket main component\");\n\n  //           this.setState({ ws: ws });\n\n  //           that.timeout = 250; // reset timer to 250 on open of websocket connection\n  //           clearTimeout(connectInterval); // clear Interval on on open of websocket connection\n  //       };\n  //       // websocket onclose event listener\n  //       ws.onclose = e => {\n  //           console.log(\n  //               `Socket is closed. Reconnect will be attempted in ${Math.min(\n  //                   10000 / 1000,\n  //                   (that.timeout + that.timeout) / 1000\n  //               )} second.`,\n  //               e.reason\n  //           );\n\n  //           that.timeout = that.timeout + that.timeout; //increment retry interval\n  //           connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n  //       };\n\n  //       // websocket onerror event listener\n  //       ws.onerror = err => {\n  //           console.error(\n  //               \"Socket encountered error: \",\n  //               err.message,\n  //               \"Closing socket\"\n  //           );\n\n  //           ws.close();\n  //       };\n\n  //       ws.addEventListener('message', function (event) {\n  //           console.log('Message from server ', event.data);\n  //           var data = JSON.parse(event.data)\n  //           if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined' ) {\n  //                   console.log('Joining session', data.session_id);\n  //                  that.setState({session: data.session_id, token: data.token, connectionCount: 2})\n\n  //           }\n\n  //           if (typeof data.username != 'undefined' ) {\n  //              that.setState({username: data.username})\n\n  //           }\n\n  //       });\n  //   };\n    /**\n     * utilited by the @function connect to check if the connection is close, if so attempts to reconnect\n     */\n    check = () => {\n        const { ws } = this.state;\n        if (!ws || ws.readyState == WebSocket.CLOSED) this.connect(); //check if websocket instance is closed, if so call `connect` function.\n    };\n\n\n  render() {\n    {console.log('renderrrr', this.state)}\n    if (this.state.session == null ){\n\n       if (this.state.username != null) {\n             return <div>Hi {this.state.username} </div>\n\n       } else  {\n             return <div>Loading..</div>\n       }\n    } else {\n      return (\n          <OTSession\n          apiKey={opentokconfig.API_KEY}\n          sessionId={this.state.session}\n          token={this.state.token}\n          eventHandlers={this.sessionEventHandlers}\n          onError={this.onError}\n    >\n\n          <OTStreams>\n            <Subscriber/>\n        </OTStreams>\n        <Publisher/>\n      </OTSession>\n      )\n    }\n  }\n\n\n}\nexport default  withRouter(Chat) \n\n"]},"metadata":{},"sourceType":"module"}