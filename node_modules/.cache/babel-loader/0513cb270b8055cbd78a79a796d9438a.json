{"ast":null,"code":"var _jsxFileName = \"/Users/tobeyasinugo/dev/facechat_django/frontend/src/pages/chat.js\";\nimport React from 'react';\nimport Publisher from '../components/Publisher';\nimport Subscriber from '../components/Subscriber';\nimport { OTSession, OTStreams, preloadScript } from 'opentok-react';\nimport opentokconfig from '../config';\nimport { useParams } from \"react-router-dom\";\nimport './chat.css';\nimport 'semantic-ui-css/semantic.min.css';\nimport config from '../config';\nimport { authenticationService } from '../services/auth.service';\n\nconst OT = require('@opentok/client');\n\nconst qs = require('qs');\n\nclass Chat extends React.Component {\n  // Initial timeout duration as a class variable\n  constructor(props) {\n    super(props);\n    this.timeout = 250;\n\n    this.connect = () => {\n      let token = authenticationService.accessToken;\n      let params = {\n        token\n      }; // let query_params = Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n\n      console.log('params', params);\n      var ws = new WebSocket(`${config.PAYTOK_WS_URL}}/paytok/?${query_params}`);\n      let that = this; // cache the this\n\n      var connectInterval; // websocket onopen event listener\n\n      ws.onopen = () => {\n        console.log(\"connected websocket main component\");\n        this.setState({\n          ws: ws\n        });\n        that.timeout = 250; // reset timer to 250 on open of websocket connection\n\n        clearTimeout(connectInterval); // clear Interval on on open of websocket connection\n      }; // websocket onclose event listener\n\n\n      ws.onclose = e => {\n        console.log(`Socket is closed. Reconnect will be attempted in ${Math.min(10000 / 1000, (that.timeout + that.timeout) / 1000)} second.`, e.reason);\n        that.timeout = that.timeout + that.timeout; //increment retry interval\n\n        connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n      }; // websocket onerror event listener\n\n\n      ws.onerror = err => {\n        console.error(\"Socket encountered error: \", err.message, \"Closing socket\");\n        ws.close();\n      };\n\n      ws.addEventListener('message', function (event) {\n        console.log('Message from server ', event.data);\n        var data = JSON.parse(event.data);\n\n        if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined') {\n          console.log('Joining session', data.session_id);\n          that.setState({\n            session: data.session_id,\n            token: data.token,\n            connectionCount: 2\n          });\n        }\n\n        if (typeof data.username != 'undefined') {\n          that.setState({\n            username: data.username\n          });\n        }\n      });\n    };\n\n    this.check = () => {\n      const {\n        ws\n      } = this.state;\n      if (!ws || ws.readyState == WebSocket.CLOSED) this.connect(); //check if websocket instance is closed, if so call `connect` function.\n    };\n\n    let {\n      influencer\n    } = useParams();\n    this.state = {\n      session: null,\n      token: null,\n      connectionCount: 0,\n      session: null,\n      ws: null,\n      username: null,\n      influencer: influencer,\n      isConnected: false\n    };\n    this._isMounted = false;\n    this.sessionEventHandlers = {\n      connectionCreated: event => {\n        console.log(\"[NEW] connection created\", event);\n        var data = {\n          connectionId: event.connection.connectionId,\n          creationTime: event.connection.creationTime,\n          data: event.connection.data,\n          event: event.type,\n          sessionId: this.state.session,\n          parser: 'connection_created'\n        };\n        console.log('sending it', data);\n        this.state.ws.send(JSON.stringify(data));\n      },\n      connectionDestroyed: event => {\n        console.log(\"connection destroyed\", event);\n      },\n      sessionConnected: event => {\n        console.log(\"Client connect to a session\");\n      },\n      sessionDisconnected: event => {\n        console.log(\"Client disConnect to a session\");\n      },\n      sessionReconnected: event => {\n        console.log(\"session reconnected\");\n      }\n    };\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  componentDidMount() {\n    this._isMounted = true; // https://stackoverflow.com/questions/52061476/cancel-all-subscriptions-and-asyncs-in-the-componentwillunmount-method-how\n\n    if (!this._isMounted) {\n      return;\n    }\n\n    console.log(\"Mounted!\");\n    authenticationService.ws.connectionStatus$.subscribe(isConnected => this.setState({\n      isConnected\n    }));\n    this.connect();\n    console.log('connected to session');\n  }\n\n  render() {\n    if (this.state.session == null) {\n      if (this.state.username != null) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 164,\n            columnNumber: 21\n          }\n        }, \"Hi \", this.state.username, \" \");\n      } else {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 167,\n            columnNumber: 21\n          }\n        }, \"Loading..\");\n      }\n    } else {\n      return /*#__PURE__*/React.createElement(OTSession, {\n        apiKey: opentokconfig.API_KEY,\n        sessionId: this.state.session,\n        token: this.state.token,\n        eventHandlers: this.sessionEventHandlers,\n        onError: this.onError,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 171,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(OTStreams, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 179,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(Subscriber, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 180,\n          columnNumber: 13\n        }\n      })), /*#__PURE__*/React.createElement(Publisher, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 182,\n          columnNumber: 9\n        }\n      }));\n    }\n  }\n\n}\n\nexport default Chat;","map":{"version":3,"sources":["/Users/tobeyasinugo/dev/facechat_django/frontend/src/pages/chat.js"],"names":["React","Publisher","Subscriber","OTSession","OTStreams","preloadScript","opentokconfig","useParams","config","authenticationService","OT","require","qs","Chat","Component","constructor","props","timeout","connect","token","accessToken","params","console","log","ws","WebSocket","PAYTOK_WS_URL","query_params","that","connectInterval","onopen","setState","clearTimeout","onclose","e","Math","min","reason","setTimeout","check","onerror","err","error","message","close","addEventListener","event","data","JSON","parse","session_id","session","connectionCount","username","state","readyState","CLOSED","influencer","isConnected","_isMounted","sessionEventHandlers","connectionCreated","connectionId","connection","creationTime","type","sessionId","parser","send","stringify","connectionDestroyed","sessionConnected","sessionDisconnected","sessionReconnected","componentWillUnmount","componentDidMount","connectionStatus$","subscribe","render","API_KEY","onError"],"mappings":"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","sourcesContent":["import React from 'react';\nimport Publisher from '../components/Publisher';\nimport Subscriber  from '../components/Subscriber';\nimport { OTSession, OTStreams, preloadScript } from 'opentok-react';\nimport opentokconfig from '../config';\nimport { useParams } from \"react-router-dom\";\nimport './chat.css'\nimport 'semantic-ui-css/semantic.min.css';\n\nimport config from '../config';\nimport { authenticationService } from '../services/auth.service';\n\n\nconst OT = require('@opentok/client');\nconst qs = require('qs');\n\nclass Chat extends React.Component {\n\n  timeout = 250; // Initial timeout duration as a class variable\n  constructor(props) {\n    super(props);\n\n    let { influencer } = useParams();\n\n    this.state = {\n      session: null,\n      token: null,\n      connectionCount: 0,\n      session: null,\n      ws: null,\n      username: null,\n      influencer: influencer,\n      isConnected: false,\n    }\n    this._isMounted = false;\n\n this.sessionEventHandlers = {\n      connectionCreated: event =>  {\n          console.log(\"[NEW] connection created\", event);\n          var data = {\n            connectionId: event.connection.connectionId,\n            creationTime: event.connection.creationTime,\n            data: event.connection.data,\n            event: event.type,\n            sessionId: this.state.session,\n            parser: 'connection_created',\n\n          }\n          console.log('sending it', data)\n          this.state.ws.send(JSON.stringify(data));\n\n\n      },\n      connectionDestroyed: event =>  {\n          console.log(\"connection destroyed\", event);\n      },\n      sessionConnected: event => {\n          console.log(\"Client connect to a session\")\n      },\n      sessionDisconnected: event => {\n        console.log(\"Client disConnect to a session\")\n      },\n      sessionReconnected: event => {\n        console.log(\"session reconnected\")\n      },\n    };\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n }\n  componentDidMount() {\n    this._isMounted = true; // https://stackoverflow.com/questions/52061476/cancel-all-subscriptions-and-asyncs-in-the-componentwillunmount-method-how\n\n    if (!this._isMounted) {\n        return\n    }\n\n\n    console.log(\"Mounted!\")\n\n\n    authenticationService.ws.connectionStatus$.subscribe(isConnected => this.setState({ isConnected }));\n\n    this.connect()\n    console.log('connected to session')\n  }\n\n\n\n   connect = () => {\n        let token = authenticationService.accessToken\n        let params = { token }\n        // let query_params = Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n\n        console.log('params', params)\n        var   ws = new WebSocket(`${config.PAYTOK_WS_URL}}/paytok/?${query_params}`)\n        let that = this; // cache the this\n        var connectInterval;\n        // websocket onopen event listener\n        ws.onopen = () => {\n            console.log(\"connected websocket main component\");\n\n            this.setState({ ws: ws });\n\n            that.timeout = 250; // reset timer to 250 on open of websocket connection\n            clearTimeout(connectInterval); // clear Interval on on open of websocket connection\n        };\n        // websocket onclose event listener\n        ws.onclose = e => {\n            console.log(\n                `Socket is closed. Reconnect will be attempted in ${Math.min(\n                    10000 / 1000,\n                    (that.timeout + that.timeout) / 1000\n                )} second.`,\n                e.reason\n            );\n\n            that.timeout = that.timeout + that.timeout; //increment retry interval\n            connectInterval = setTimeout(this.check, Math.min(10000, that.timeout)); //call check function after timeout\n        };\n\n        // websocket onerror event listener\n        ws.onerror = err => {\n            console.error(\n                \"Socket encountered error: \",\n                err.message,\n                \"Closing socket\"\n            );\n\n            ws.close();\n        };\n\n        ws.addEventListener('message', function (event) {\n            console.log('Message from server ', event.data);\n            var data = JSON.parse(event.data)\n            if (typeof data.token != 'undefined' && typeof data.session_id != 'undefined' ) {\n                    console.log('Joining session', data.session_id);\n                   that.setState({session: data.session_id, token: data.token, connectionCount: 2})\n\n            }\n\n            if (typeof data.username != 'undefined' ) {\n               that.setState({username: data.username})\n\n            }\n\n        });\n    };\n    /**\n     * utilited by the @function connect to check if the connection is close, if so attempts to reconnect\n     */\n    check = () => {\n        const { ws } = this.state;\n        if (!ws || ws.readyState == WebSocket.CLOSED) this.connect(); //check if websocket instance is closed, if so call `connect` function.\n    };\n\n\n  render() {\n\n    if (this.state.session == null ){\n\n       if (this.state.username != null) {\n             return <div>Hi {this.state.username} </div>\n\n       } else  {\n             return <div>Loading..</div>\n       }\n    } else {\n      return (\n          <OTSession\n          apiKey={opentokconfig.API_KEY}\n          sessionId={this.state.session}\n          token={this.state.token}\n          eventHandlers={this.sessionEventHandlers}\n          onError={this.onError}\n    >\n\n          <OTStreams>\n            <Subscriber/>\n        </OTStreams>\n        <Publisher/>\n      </OTSession>\n      )\n    }\n  }\n\n\n}\nexport default  Chat\n\n"]},"metadata":{},"sourceType":"module"}