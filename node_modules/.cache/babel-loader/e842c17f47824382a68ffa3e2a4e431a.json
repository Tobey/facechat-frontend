{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar buffer_1 = require(\"buffer\");\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar root_1 = require(\"rxjs/internal/util/root\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar webSocket_1 = require(\"rxjs/webSocket\");\n\nvar ws = require(\"websocket\");\n/**\n * Class definition\n */\n\n\nvar RxSocketClientSubject =\n/** @class */\nfunction (_super) {\n  __extends(RxSocketClientSubject, _super);\n  /**\n   * Class constructor\n   *\n   * @param urlConfigOrSource\n   */\n\n\n  function RxSocketClientSubject(urlConfigOrSource) {\n    var _this = _super.call(this) || this; // define connection status subject\n\n\n    _this._connectionStatus$ = new rxjs_1.Subject(); // set reconnect interval\n\n    if (urlConfigOrSource.reconnectInterval) {\n      _this._reconnectInterval = urlConfigOrSource.reconnectInterval;\n    } else {\n      _this._reconnectInterval = 5000;\n    } // set reconnect attempts\n\n\n    if (urlConfigOrSource.reconnectAttempts) {\n      _this._reconnectAttempts = urlConfigOrSource.reconnectAttempts;\n    } else {\n      _this._reconnectAttempts = 10;\n    } // check type of constructor's parameter to add url in config\n\n\n    if (typeof urlConfigOrSource === 'string') {\n      // create minimum config object\n      _this._wsSubjectConfig = Object.assign({}, {\n        url: urlConfigOrSource\n      });\n    } else {\n      // create minimum config object\n      _this._wsSubjectConfig = Object.assign({}, {\n        url: urlConfigOrSource.url\n      });\n    } // add protocol in config\n\n\n    if (urlConfigOrSource.protocol) {\n      Object.assign(_this._wsSubjectConfig, {\n        protocol: urlConfigOrSource.protocol\n      });\n    } // node environment\n\n\n    if (!root_1.root.WebSocket) {\n      root_1.root['WebSocket'] = ws['w3cwebsocket'];\n    } // add WebSocketCtor in config\n\n\n    if (urlConfigOrSource.WebSocketCtor) {\n      Object.assign(_this._wsSubjectConfig, {\n        WebSocketCtor: urlConfigOrSource.WebSocketCtor\n      });\n    } // add binaryType in config\n\n\n    if (urlConfigOrSource.binaryType) {\n      Object.assign(_this._wsSubjectConfig, {\n        binaryType: urlConfigOrSource.binaryType\n      });\n    } // add default data in config\n\n\n    Object.assign(_this._wsSubjectConfig, {\n      deserializer: _this._deserializer,\n      serializer: _this._serializer,\n      openObserver: {\n        next: function () {\n          _this._connectionStatus$.next(true);\n        }\n      },\n      closeObserver: {\n        next: function () {\n          _this._cleanSocket();\n\n          _this._connectionStatus$.next(false);\n        }\n      }\n    }); // connect socket\n\n    _this._connect(); // connection status subscription\n\n\n    _this.connectionStatus$.subscribe(function (isConnected) {\n      if (!_this._reconnectionObservable && typeof isConnected === 'boolean' && !isConnected) {\n        _this._reconnect();\n      }\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(RxSocketClientSubject.prototype, \"connectionStatus$\", {\n    /**\n     * Returns connection status observable\n     *\n     * @return {Observable<boolean>}\n     */\n    get: function () {\n      return this._connectionStatus$.pipe(operators_1.distinctUntilChanged());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Function to send data by socket\n   *\n   * @param data\n   */\n\n  RxSocketClientSubject.prototype.send = function (data) {\n    this._socket.next(data);\n  };\n  /**\n   * Function to handle text response for given event from server\n   *\n   * @example <caption>UTF Text Message from server</caption>\n   *\n   * const message = {\n   *  type: 'utf8',\n   *  utf8Data: {\n   *      event: 'data',\n   *      data: 'Data from the server'\n   *  }\n   * }\n   *\n   * @example <caption>Simple Text Message from server</caption>\n   *\n   * const message = {\n   *  event: 'data',\n   *  data: 'Data from the server'\n   * }\n   *\n   * @param event represents value inside {utf8Data.event} or {event} from server response\n   *\n   *  @value complete | <any>\n   *  @example <caption>Event type</caption>\n   *\n   *  if (event === 'complete') => handle Observable's complete\n   *  else handle Observable's success\n   *\n   * @param cb is the function executed if event matches the response from the server\n   */\n\n\n  RxSocketClientSubject.prototype.on = function (event, cb) {\n    this._message$(event).subscribe(function (message) {\n      return cb(message.data);\n    },\n    /* istanbul ignore next */\n    function () {\n      return undefined;\n    }, function () {\n      /* istanbul ignore else */\n      if (event === 'close') {\n        cb();\n      }\n    });\n  };\n  /**\n   * Function to handle bytes response from server\n   *\n   * @example <caption>Bytes Message from server</caption>\n   *\n   * const message = {\n   *  type: 'binary',\n   *  binaryData: <Buffer 74 6f 74 6f>\n   * }\n   *\n   * @example <caption>Simple Bytes Message from server</caption>\n   *\n   * const message = <Buffer 74 6f 74 6f>\n   *\n   * @param cb is the function executed if event matches the response from the server\n   */\n\n\n  RxSocketClientSubject.prototype.onBytes = function (cb) {\n    this.onBytes$().subscribe(function (message) {\n      return cb(message);\n    });\n  };\n  /**\n   * Same as `on` method but with Observable response\n   *\n   * @param event represents value inside {utf8Data.event} or {event} from server response\n   *\n   * @return {Observable<any>}\n   */\n\n\n  RxSocketClientSubject.prototype.on$ = function (event) {\n    return this._message$(event).pipe(operators_1.map(function (_) {\n      return _.data;\n    }));\n  };\n  /**\n   * Function to handle socket close event from server with Observable\n   *\n   * @return {Observable<void>}\n   */\n\n\n  RxSocketClientSubject.prototype.onClose$ = function () {\n    var _this = this;\n\n    return new rxjs_1.Observable(function (observer) {\n      _this.subscribe(\n      /* istanbul ignore next */\n      function () {\n        return undefined;\n      },\n      /* istanbul ignore next */\n      function () {\n        return undefined;\n      }, function () {\n        observer.next();\n        observer.complete();\n      });\n    });\n  };\n  /**\n   * Returns formatted binary from server with Observable\n   *\n   * @return {Observable<WebSocketBinaryServer>}\n   *\n   * @private\n   */\n\n\n  RxSocketClientSubject.prototype.onBytes$ = function () {\n    return this.pipe(operators_1.map(function (message) {\n      return message.type && message.type === 'binary' && message.binaryData ? message.binaryData : message;\n    }));\n  };\n  /**\n   * Function to emit data for given event to server\n   *\n   * @param event type of data for the server request\n   * @param data request data\n   */\n\n\n  RxSocketClientSubject.prototype.emit = function (event, data) {\n    this.send({\n      event: event,\n      data: data\n    });\n  };\n  /**\n   * Returns formatted and filtered message from server for given event with Observable\n   *\n   * @param {string | \"close\"} event represents value inside {utf8Data.event} or {event} from server response\n   *\n   * @return {Observable<WebSocketMessageServer>}\n   *\n   * @private\n   */\n\n\n  RxSocketClientSubject.prototype._message$ = function (event) {\n    return this.pipe(operators_1.map(function (message) {\n      return message.type && message.type === 'utf8' && message.utf8Data ? message.utf8Data : message;\n    }), operators_1.filter(function (message) {\n      return message.event && message.event !== 'close' && message.event === event && message.data;\n    }));\n  };\n  /**\n   * Function to clean socket data\n   *\n   * @private\n   */\n\n\n  RxSocketClientSubject.prototype._cleanSocket = function () {\n    /* istanbul ignore else */\n    if (this._socketSubscription) {\n      this._socketSubscription.unsubscribe();\n    }\n\n    this._socket = undefined;\n  };\n  /**\n   * Function to clean reconnection data\n   *\n   * @private\n   */\n\n\n  RxSocketClientSubject.prototype._cleanReconnection = function () {\n    /* istanbul ignore else */\n    if (this._reconnectionSubscription) {\n      this._reconnectionSubscription.unsubscribe();\n    }\n\n    this._reconnectionObservable = undefined;\n  };\n  /**\n   * Function to create socket and subscribe to it\n   *\n   * @private\n   */\n\n\n  RxSocketClientSubject.prototype._connect = function () {\n    var _this = this;\n\n    this._socket = new webSocket_1.WebSocketSubject(this._wsSubjectConfig);\n    this._socketSubscription = this._socket.subscribe(function (m) {\n      _this.next(m);\n    }, function () {\n      /* istanbul ignore if */\n      if (!_this._socket) {\n        _this._cleanReconnection();\n\n        _this._reconnect();\n      }\n    });\n  };\n  /**\n   * Function to reconnect socket\n   *\n   * @private\n   */\n\n\n  RxSocketClientSubject.prototype._reconnect = function () {\n    var _this = this;\n\n    this._reconnectionObservable = rxjs_1.interval(this._reconnectInterval).pipe(operators_1.takeWhile(function (v, index) {\n      return index < _this._reconnectAttempts && !_this._socket;\n    }));\n    this._reconnectionSubscription = this._reconnectionObservable.subscribe(function () {\n      return _this._connect();\n    },\n    /* istanbul ignore next */\n    function () {\n      return undefined;\n    }, function () {\n      _this._cleanReconnection();\n\n      if (!_this._socket) {\n        _this.complete();\n\n        _this._connectionStatus$.complete();\n      }\n    });\n  };\n  /**\n   * Default deserializer\n   *\n   * @param e\n   *\n   * @return {any}\n   * @private\n   */\n\n\n  RxSocketClientSubject.prototype._deserializer = function (e) {\n    try {\n      return JSON.parse(e.data);\n    } catch (err) {\n      return e.data;\n    }\n  };\n\n  ;\n  /**\n   * Default serializer\n   *\n   * @param data\n   *\n   * @return {WebSocketMessage}\n   * @private\n   */\n\n  RxSocketClientSubject.prototype._serializer = function (data) {\n    return typeof data === 'string' || buffer_1.Buffer.isBuffer(data) ? data : JSON.stringify(data);\n  };\n\n  ;\n  return RxSocketClientSubject;\n}(rxjs_1.Subject);\n\nexports.RxSocketClientSubject = RxSocketClientSubject;","map":{"version":3,"sources":["../../../src/lib/rx-socket-client.subject.ts"],"names":[],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport { interval, Observable, Subject, Subscription } from 'rxjs';\nimport { root } from 'rxjs/internal/util/root';\nimport { distinctUntilChanged, filter, map, takeWhile } from 'rxjs/operators';\nimport { WebSocketSubject, WebSocketSubjectConfig } from 'rxjs/webSocket';\n\nimport * as ws from 'websocket';\n\n/**\n * Extends default config to add reconnection data and serializer\n */\nexport interface RxSocketClientConfig {\n    /** The url of the socket server to connect to */\n    url: string;\n    /** The protocol to use to connect */\n    protocol?: string | Array<string>;\n    /**\n     * A WebSocket constructor to use. This is useful for mocking a WebSocket\n     * for testing purposes\n     */\n    WebSocketCtor?: { new(url: string, protocol?: string | Array<string>): WebSocket };\n    /** Sets the `binaryType` property of the underlying WebSocket. */\n    binaryType?: 'blob' | 'arraybuffer';\n    /** Sets the reconnection interval value. */\n    reconnectInterval?: number;\n    /** Sets the reconnection attempts value. */\n    reconnectAttempts?: number;\n}\n\n/** Type of message sent to server */\nexport type WebSocketMessage = string | Buffer | ArrayBuffer | Blob | ArrayBufferView;\n\n/** Type of message received from server */\nexport type WebSocketMessageServer = {\n    event: string;\n    data: string;\n}\n\n/** Type of binary received from server */\nexport type WebSocketBinaryServer = Buffer | ArrayBuffer | Blob | ArrayBufferView;\n\n/**\n * Class definition\n */\nexport class RxSocketClientSubject<T> extends Subject<T> {\n    // Observable for reconnection stream\n    private _reconnectionObservable: Observable<number>;\n    // WebSocketSubjectConfig instance\n    private _wsSubjectConfig: WebSocketSubjectConfig<T>;\n    // WebSocketSubject instance\n    private _socket: WebSocketSubject<any>;\n    // Subject for connection status stream\n    private _connectionStatus$: Subject<boolean>;\n    // Socket Subscription\n    private _socketSubscription: Subscription;\n    // Reconnection Subscription\n    private _reconnectionSubscription: Subscription;\n    // Reconnect interval\n    private _reconnectInterval: number;\n    // Reconnect attempts\n    private _reconnectAttempts: number;\n\n    /**\n     * Class constructor\n     *\n     * @param urlConfigOrSource\n     */\n    constructor(urlConfigOrSource: string | RxSocketClientConfig) {\n        super();\n\n        // define connection status subject\n        this._connectionStatus$ = new Subject<boolean>();\n\n        // set reconnect interval\n        if ((urlConfigOrSource as RxSocketClientConfig).reconnectInterval) {\n            this._reconnectInterval = (urlConfigOrSource as RxSocketClientConfig).reconnectInterval;\n        } else {\n            this._reconnectInterval = 5000;\n        }\n\n        // set reconnect attempts\n        if ((urlConfigOrSource as RxSocketClientConfig).reconnectAttempts) {\n            this._reconnectAttempts = (urlConfigOrSource as RxSocketClientConfig).reconnectAttempts;\n        } else {\n            this._reconnectAttempts = 10;\n        }\n\n        // check type of constructor's parameter to add url in config\n        if (typeof urlConfigOrSource === 'string') {\n            // create minimum config object\n            this._wsSubjectConfig = Object.assign({}, { url: urlConfigOrSource });\n        } else {\n            // create minimum config object\n            this._wsSubjectConfig = Object.assign({}, { url: urlConfigOrSource.url });\n        }\n\n        // add protocol in config\n        if ((urlConfigOrSource as RxSocketClientConfig).protocol) {\n            Object.assign(this._wsSubjectConfig, { protocol: (urlConfigOrSource as RxSocketClientConfig).protocol });\n        }\n\n        // node environment\n        if (!root.WebSocket) {\n            root[ 'WebSocket' ] = ws[ 'w3cwebsocket' ];\n        }\n\n        // add WebSocketCtor in config\n        if ((urlConfigOrSource as RxSocketClientConfig).WebSocketCtor) {\n            Object.assign(this._wsSubjectConfig, { WebSocketCtor: (urlConfigOrSource as RxSocketClientConfig).WebSocketCtor });\n        }\n\n        // add binaryType in config\n        if ((urlConfigOrSource as RxSocketClientConfig).binaryType) {\n            Object.assign(this._wsSubjectConfig, { binaryType: (urlConfigOrSource as RxSocketClientConfig).binaryType });\n        }\n\n        // add default data in config\n        Object.assign(this._wsSubjectConfig, {\n            deserializer: this._deserializer,\n            serializer: this._serializer,\n            openObserver: {\n                next: () => {\n                    this._connectionStatus$.next(true);\n                }\n            },\n            closeObserver: {\n                next: () => {\n                    this._cleanSocket();\n                    this._connectionStatus$.next(false);\n                }\n            }\n        });\n\n        // connect socket\n        this._connect();\n\n        // connection status subscription\n        this.connectionStatus$.subscribe(isConnected => {\n            if (!this._reconnectionObservable && typeof (isConnected) === 'boolean' && !isConnected) {\n                this._reconnect();\n            }\n        });\n    }\n\n    /**\n     * Returns connection status observable\n     *\n     * @return {Observable<boolean>}\n     */\n    get connectionStatus$(): Observable<boolean> {\n        return this._connectionStatus$\n            .pipe(\n                distinctUntilChanged()\n            );\n    }\n\n    /**\n     * Function to send data by socket\n     *\n     * @param data\n     */\n    send(data: any): void {\n        this._socket.next(data);\n    }\n\n    /**\n     * Function to handle text response for given event from server\n     *\n     * @example <caption>UTF Text Message from server</caption>\n     *\n     * const message = {\n     *  type: 'utf8',\n     *  utf8Data: {\n     *      event: 'data',\n     *      data: 'Data from the server'\n     *  }\n     * }\n     *\n     * @example <caption>Simple Text Message from server</caption>\n     *\n     * const message = {\n     *  event: 'data',\n     *  data: 'Data from the server'\n     * }\n     *\n     * @param event represents value inside {utf8Data.event} or {event} from server response\n     *\n     *  @value complete | <any>\n     *  @example <caption>Event type</caption>\n     *\n     *  if (event === 'complete') => handle Observable's complete\n     *  else handle Observable's success\n     *\n     * @param cb is the function executed if event matches the response from the server\n     */\n    on(event: string | 'close', cb: (data?: any) => void): void {\n        this._message$<WebSocketMessageServer>(event)\n            .subscribe(\n                (message: WebSocketMessageServer): void => cb(message.data),\n                /* istanbul ignore next */\n                () => undefined,\n                (): void => {\n                    /* istanbul ignore else */\n                    if (event === 'close') {\n                        cb();\n                    }\n                }\n            );\n    }\n\n    /**\n     * Function to handle bytes response from server\n     *\n     * @example <caption>Bytes Message from server</caption>\n     *\n     * const message = {\n     *  type: 'binary',\n     *  binaryData: <Buffer 74 6f 74 6f>\n     * }\n     *\n     * @example <caption>Simple Bytes Message from server</caption>\n     *\n     * const message = <Buffer 74 6f 74 6f>\n     *\n     * @param cb is the function executed if event matches the response from the server\n     */\n    onBytes(cb: (data: WebSocketBinaryServer) => void): void {\n        this.onBytes$()\n            .subscribe(\n                (message: WebSocketBinaryServer): void => cb(message)\n            );\n    }\n\n    /**\n     * Same as `on` method but with Observable response\n     *\n     * @param event represents value inside {utf8Data.event} or {event} from server response\n     *\n     * @return {Observable<any>}\n     */\n    on$(event: string): Observable<any> {\n        return this._message$<WebSocketMessageServer>(event)\n            .pipe(\n                map(_ => _.data)\n            );\n    }\n\n    /**\n     * Function to handle socket close event from server with Observable\n     *\n     * @return {Observable<void>}\n     */\n    onClose$(): Observable<void> {\n        return new Observable(observer => {\n            this.subscribe(\n                /* istanbul ignore next */\n                () => undefined,\n                /* istanbul ignore next */\n                () => undefined,\n                () => {\n                    observer.next();\n                    observer.complete();\n                });\n        });\n    }\n\n    /**\n     * Returns formatted binary from server with Observable\n     *\n     * @return {Observable<WebSocketBinaryServer>}\n     *\n     * @private\n     */\n    onBytes$(): Observable<WebSocketBinaryServer> {\n        return this\n            .pipe(\n                map((message: any): any =>\n                    (message.type && message.type === 'binary' && message.binaryData) ?\n                        message.binaryData :\n                        message\n                )\n            );\n    }\n\n    /**\n     * Function to emit data for given event to server\n     *\n     * @param event type of data for the server request\n     * @param data request data\n     */\n    emit(event: string, data: any): void {\n        this.send({ event, data });\n    }\n\n    /**\n     * Returns formatted and filtered message from server for given event with Observable\n     *\n     * @param {string | \"close\"} event represents value inside {utf8Data.event} or {event} from server response\n     *\n     * @return {Observable<WebSocketMessageServer>}\n     *\n     * @private\n     */\n    private _message$<WebSocketMessageServer>(event: string | 'close'): Observable<WebSocketMessageServer> {\n        return this\n            .pipe(\n                map((message: any): any =>\n                    (message.type && message.type === 'utf8' && message.utf8Data) ?\n                        message.utf8Data :\n                        message\n                ),\n                filter((message: any): boolean =>\n                    message.event &&\n                    message.event !== 'close' &&\n                    message.event === event &&\n                    message.data\n                )\n            );\n    }\n\n    /**\n     * Function to clean socket data\n     *\n     * @private\n     */\n    private _cleanSocket(): void {\n        /* istanbul ignore else */\n        if (this._socketSubscription) {\n            this._socketSubscription.unsubscribe();\n        }\n        this._socket = undefined;\n    }\n\n    /**\n     * Function to clean reconnection data\n     *\n     * @private\n     */\n    private _cleanReconnection(): void {\n        /* istanbul ignore else */\n        if (this._reconnectionSubscription) {\n            this._reconnectionSubscription.unsubscribe();\n        }\n        this._reconnectionObservable = undefined;\n    }\n\n    /**\n     * Function to create socket and subscribe to it\n     *\n     * @private\n     */\n    private _connect() {\n        this._socket = new WebSocketSubject(this._wsSubjectConfig);\n        this._socketSubscription = this._socket.subscribe(\n            (m: any) => {\n                this.next(m);\n            },\n            () => {\n                /* istanbul ignore if */\n                if (!this._socket) {\n                    this._cleanReconnection();\n                    this._reconnect();\n                }\n            }\n        );\n    }\n\n    /**\n     * Function to reconnect socket\n     *\n     * @private\n     */\n    private _reconnect(): void {\n        this._reconnectionObservable = interval(this._reconnectInterval)\n            .pipe(\n                takeWhile((v, index) => index < this._reconnectAttempts && !this._socket)\n            );\n\n        this._reconnectionSubscription = this._reconnectionObservable.subscribe(\n            () => this._connect(),\n            /* istanbul ignore next */\n            () => undefined,\n            () => {\n                this._cleanReconnection();\n                if (!this._socket) {\n                    this.complete();\n                    this._connectionStatus$.complete();\n                }\n            }\n        );\n    }\n\n    /**\n     * Default deserializer\n     *\n     * @param e\n     *\n     * @return {any}\n     * @private\n     */\n    private _deserializer(e: MessageEvent): T {\n        try {\n            return JSON.parse(e.data);\n        } catch (err) {\n            return e.data;\n        }\n    };\n\n    /**\n     * Default serializer\n     *\n     * @param data\n     *\n     * @return {WebSocketMessage}\n     * @private\n     */\n    private _serializer(data: any): WebSocketMessage {\n        return typeof (data) === 'string' || Buffer.isBuffer(data) ? data : JSON.stringify(data);\n    };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}