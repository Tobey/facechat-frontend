"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = require("buffer");
var rxjs_1 = require("rxjs");
var root_1 = require("rxjs/internal/util/root");
var operators_1 = require("rxjs/operators");
var webSocket_1 = require("rxjs/webSocket");
var ws = require("websocket");
/**
 * Class definition
 */
var RxSocketClientSubject = /** @class */ (function (_super) {
    __extends(RxSocketClientSubject, _super);
    /**
     * Class constructor
     *
     * @param urlConfigOrSource
     */
    function RxSocketClientSubject(urlConfigOrSource) {
        var _this = _super.call(this) || this;
        // define connection status subject
        _this._connectionStatus$ = new rxjs_1.Subject();
        // set reconnect interval
        if (urlConfigOrSource.reconnectInterval) {
            _this._reconnectInterval = urlConfigOrSource.reconnectInterval;
        }
        else {
            _this._reconnectInterval = 5000;
        }
        // set reconnect attempts
        if (urlConfigOrSource.reconnectAttempts) {
            _this._reconnectAttempts = urlConfigOrSource.reconnectAttempts;
        }
        else {
            _this._reconnectAttempts = 10;
        }
        // check type of constructor's parameter to add url in config
        if (typeof urlConfigOrSource === 'string') {
            // create minimum config object
            _this._wsSubjectConfig = Object.assign({}, { url: urlConfigOrSource });
        }
        else {
            // create minimum config object
            _this._wsSubjectConfig = Object.assign({}, { url: urlConfigOrSource.url });
        }
        // add protocol in config
        if (urlConfigOrSource.protocol) {
            Object.assign(_this._wsSubjectConfig, { protocol: urlConfigOrSource.protocol });
        }
        // node environment
        if (!root_1.root.WebSocket) {
            root_1.root['WebSocket'] = ws['w3cwebsocket'];
        }
        // add WebSocketCtor in config
        if (urlConfigOrSource.WebSocketCtor) {
            Object.assign(_this._wsSubjectConfig, { WebSocketCtor: urlConfigOrSource.WebSocketCtor });
        }
        // add binaryType in config
        if (urlConfigOrSource.binaryType) {
            Object.assign(_this._wsSubjectConfig, { binaryType: urlConfigOrSource.binaryType });
        }
        // add default data in config
        Object.assign(_this._wsSubjectConfig, {
            deserializer: _this._deserializer,
            serializer: _this._serializer,
            openObserver: {
                next: function () {
                    _this._connectionStatus$.next(true);
                }
            },
            closeObserver: {
                next: function () {
                    _this._cleanSocket();
                    _this._connectionStatus$.next(false);
                }
            }
        });
        // connect socket
        _this._connect();
        // connection status subscription
        _this.connectionStatus$.subscribe(function (isConnected) {
            if (!_this._reconnectionObservable && typeof (isConnected) === 'boolean' && !isConnected) {
                _this._reconnect();
            }
        });
        return _this;
    }
    Object.defineProperty(RxSocketClientSubject.prototype, "connectionStatus$", {
        /**
         * Returns connection status observable
         *
         * @return {Observable<boolean>}
         */
        get: function () {
            return this._connectionStatus$
                .pipe(operators_1.distinctUntilChanged());
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Function to send data by socket
     *
     * @param data
     */
    RxSocketClientSubject.prototype.send = function (data) {
        this._socket.next(data);
    };
    /**
     * Function to handle text response for given event from server
     *
     * @example <caption>UTF Text Message from server</caption>
     *
     * const message = {
     *  type: 'utf8',
     *  utf8Data: {
     *      event: 'data',
     *      data: 'Data from the server'
     *  }
     * }
     *
     * @example <caption>Simple Text Message from server</caption>
     *
     * const message = {
     *  event: 'data',
     *  data: 'Data from the server'
     * }
     *
     * @param event represents value inside {utf8Data.event} or {event} from server response
     *
     *  @value complete | <any>
     *  @example <caption>Event type</caption>
     *
     *  if (event === 'complete') => handle Observable's complete
     *  else handle Observable's success
     *
     * @param cb is the function executed if event matches the response from the server
     */
    RxSocketClientSubject.prototype.on = function (event, cb) {
        this._message$(event)
            .subscribe(function (message) { return cb(message.data); }, 
        /* istanbul ignore next */
        function () { return undefined; }, function () {
            /* istanbul ignore else */
            if (event === 'close') {
                cb();
            }
        });
    };
    /**
     * Function to handle bytes response from server
     *
     * @example <caption>Bytes Message from server</caption>
     *
     * const message = {
     *  type: 'binary',
     *  binaryData: <Buffer 74 6f 74 6f>
     * }
     *
     * @example <caption>Simple Bytes Message from server</caption>
     *
     * const message = <Buffer 74 6f 74 6f>
     *
     * @param cb is the function executed if event matches the response from the server
     */
    RxSocketClientSubject.prototype.onBytes = function (cb) {
        this.onBytes$()
            .subscribe(function (message) { return cb(message); });
    };
    /**
     * Same as `on` method but with Observable response
     *
     * @param event represents value inside {utf8Data.event} or {event} from server response
     *
     * @return {Observable<any>}
     */
    RxSocketClientSubject.prototype.on$ = function (event) {
        return this._message$(event)
            .pipe(operators_1.map(function (_) { return _.data; }));
    };
    /**
     * Function to handle socket close event from server with Observable
     *
     * @return {Observable<void>}
     */
    RxSocketClientSubject.prototype.onClose$ = function () {
        var _this = this;
        return new rxjs_1.Observable(function (observer) {
            _this.subscribe(
            /* istanbul ignore next */
            function () { return undefined; }, 
            /* istanbul ignore next */
            function () { return undefined; }, function () {
                observer.next();
                observer.complete();
            });
        });
    };
    /**
     * Returns formatted binary from server with Observable
     *
     * @return {Observable<WebSocketBinaryServer>}
     *
     * @private
     */
    RxSocketClientSubject.prototype.onBytes$ = function () {
        return this
            .pipe(operators_1.map(function (message) {
            return (message.type && message.type === 'binary' && message.binaryData) ?
                message.binaryData :
                message;
        }));
    };
    /**
     * Function to emit data for given event to server
     *
     * @param event type of data for the server request
     * @param data request data
     */
    RxSocketClientSubject.prototype.emit = function (event, data) {
        this.send({ event: event, data: data });
    };
    /**
     * Returns formatted and filtered message from server for given event with Observable
     *
     * @param {string | "close"} event represents value inside {utf8Data.event} or {event} from server response
     *
     * @return {Observable<WebSocketMessageServer>}
     *
     * @private
     */
    RxSocketClientSubject.prototype._message$ = function (event) {
        return this
            .pipe(operators_1.map(function (message) {
            return (message.type && message.type === 'utf8' && message.utf8Data) ?
                message.utf8Data :
                message;
        }), operators_1.filter(function (message) {
            return message.event &&
                message.event !== 'close' &&
                message.event === event &&
                message.data;
        }));
    };
    /**
     * Function to clean socket data
     *
     * @private
     */
    RxSocketClientSubject.prototype._cleanSocket = function () {
        /* istanbul ignore else */
        if (this._socketSubscription) {
            this._socketSubscription.unsubscribe();
        }
        this._socket = undefined;
    };
    /**
     * Function to clean reconnection data
     *
     * @private
     */
    RxSocketClientSubject.prototype._cleanReconnection = function () {
        /* istanbul ignore else */
        if (this._reconnectionSubscription) {
            this._reconnectionSubscription.unsubscribe();
        }
        this._reconnectionObservable = undefined;
    };
    /**
     * Function to create socket and subscribe to it
     *
     * @private
     */
    RxSocketClientSubject.prototype._connect = function () {
        var _this = this;
        this._socket = new webSocket_1.WebSocketSubject(this._wsSubjectConfig);
        this._socketSubscription = this._socket.subscribe(function (m) {
            _this.next(m);
        }, function () {
            /* istanbul ignore if */
            if (!_this._socket) {
                _this._cleanReconnection();
                _this._reconnect();
            }
        });
    };
    /**
     * Function to reconnect socket
     *
     * @private
     */
    RxSocketClientSubject.prototype._reconnect = function () {
        var _this = this;
        this._reconnectionObservable = rxjs_1.interval(this._reconnectInterval)
            .pipe(operators_1.takeWhile(function (v, index) { return index < _this._reconnectAttempts && !_this._socket; }));
        this._reconnectionSubscription = this._reconnectionObservable.subscribe(function () { return _this._connect(); }, 
        /* istanbul ignore next */
        function () { return undefined; }, function () {
            _this._cleanReconnection();
            if (!_this._socket) {
                _this.complete();
                _this._connectionStatus$.complete();
            }
        });
    };
    /**
     * Default deserializer
     *
     * @param e
     *
     * @return {any}
     * @private
     */
    RxSocketClientSubject.prototype._deserializer = function (e) {
        try {
            return JSON.parse(e.data);
        }
        catch (err) {
            return e.data;
        }
    };
    ;
    /**
     * Default serializer
     *
     * @param data
     *
     * @return {WebSocketMessage}
     * @private
     */
    RxSocketClientSubject.prototype._serializer = function (data) {
        return typeof (data) === 'string' || buffer_1.Buffer.isBuffer(data) ? data : JSON.stringify(data);
    };
    ;
    return RxSocketClientSubject;
}(rxjs_1.Subject));
exports.RxSocketClientSubject = RxSocketClientSubject;
//# sourceMappingURL=rx-socket-client.subject.js.map