/// <reference types="node" />
import { Observable, Subject } from 'rxjs';
/**
 * Extends default config to add reconnection data and serializer
 */
export interface RxSocketClientConfig {
    /** The url of the socket server to connect to */
    url: string;
    /** The protocol to use to connect */
    protocol?: string | Array<string>;
    /**
     * A WebSocket constructor to use. This is useful for mocking a WebSocket
     * for testing purposes
     */
    WebSocketCtor?: {
        new (url: string, protocol?: string | Array<string>): WebSocket;
    };
    /** Sets the `binaryType` property of the underlying WebSocket. */
    binaryType?: 'blob' | 'arraybuffer';
    /** Sets the reconnection interval value. */
    reconnectInterval?: number;
    /** Sets the reconnection attempts value. */
    reconnectAttempts?: number;
}
/** Type of message sent to server */
export declare type WebSocketMessage = string | Buffer | ArrayBuffer | Blob | ArrayBufferView;
/** Type of message received from server */
export declare type WebSocketMessageServer = {
    event: string;
    data: string;
};
/** Type of binary received from server */
export declare type WebSocketBinaryServer = Buffer | ArrayBuffer | Blob | ArrayBufferView;
/**
 * Class definition
 */
export declare class RxSocketClientSubject<T> extends Subject<T> {
    private _reconnectionObservable;
    private _wsSubjectConfig;
    private _socket;
    private _connectionStatus$;
    private _socketSubscription;
    private _reconnectionSubscription;
    private _reconnectInterval;
    private _reconnectAttempts;
    /**
     * Class constructor
     *
     * @param urlConfigOrSource
     */
    constructor(urlConfigOrSource: string | RxSocketClientConfig);
    /**
     * Returns connection status observable
     *
     * @return {Observable<boolean>}
     */
    readonly connectionStatus$: Observable<boolean>;
    /**
     * Function to send data by socket
     *
     * @param data
     */
    send(data: any): void;
    /**
     * Function to handle text response for given event from server
     *
     * @example <caption>UTF Text Message from server</caption>
     *
     * const message = {
     *  type: 'utf8',
     *  utf8Data: {
     *      event: 'data',
     *      data: 'Data from the server'
     *  }
     * }
     *
     * @example <caption>Simple Text Message from server</caption>
     *
     * const message = {
     *  event: 'data',
     *  data: 'Data from the server'
     * }
     *
     * @param event represents value inside {utf8Data.event} or {event} from server response
     *
     *  @value complete | <any>
     *  @example <caption>Event type</caption>
     *
     *  if (event === 'complete') => handle Observable's complete
     *  else handle Observable's success
     *
     * @param cb is the function executed if event matches the response from the server
     */
    on(event: string | 'close', cb: (data?: any) => void): void;
    /**
     * Function to handle bytes response from server
     *
     * @example <caption>Bytes Message from server</caption>
     *
     * const message = {
     *  type: 'binary',
     *  binaryData: <Buffer 74 6f 74 6f>
     * }
     *
     * @example <caption>Simple Bytes Message from server</caption>
     *
     * const message = <Buffer 74 6f 74 6f>
     *
     * @param cb is the function executed if event matches the response from the server
     */
    onBytes(cb: (data: WebSocketBinaryServer) => void): void;
    /**
     * Same as `on` method but with Observable response
     *
     * @param event represents value inside {utf8Data.event} or {event} from server response
     *
     * @return {Observable<any>}
     */
    on$(event: string): Observable<any>;
    /**
     * Function to handle socket close event from server with Observable
     *
     * @return {Observable<void>}
     */
    onClose$(): Observable<void>;
    /**
     * Returns formatted binary from server with Observable
     *
     * @return {Observable<WebSocketBinaryServer>}
     *
     * @private
     */
    onBytes$(): Observable<WebSocketBinaryServer>;
    /**
     * Function to emit data for given event to server
     *
     * @param event type of data for the server request
     * @param data request data
     */
    emit(event: string, data: any): void;
    /**
     * Returns formatted and filtered message from server for given event with Observable
     *
     * @param {string | "close"} event represents value inside {utf8Data.event} or {event} from server response
     *
     * @return {Observable<WebSocketMessageServer>}
     *
     * @private
     */
    private _message$;
    /**
     * Function to clean socket data
     *
     * @private
     */
    private _cleanSocket;
    /**
     * Function to clean reconnection data
     *
     * @private
     */
    private _cleanReconnection;
    /**
     * Function to create socket and subscribe to it
     *
     * @private
     */
    private _connect;
    /**
     * Function to reconnect socket
     *
     * @private
     */
    private _reconnect;
    /**
     * Default deserializer
     *
     * @param e
     *
     * @return {any}
     * @private
     */
    private _deserializer;
    /**
     * Default serializer
     *
     * @param data
     *
     * @return {WebSocketMessage}
     * @private
     */
    private _serializer;
}
